---
tags: [线程池, 框架]
categories: [代码框架]
---

# 动态线程池DTP

```xml
<!-- apollo 版本 -->
<dependency>
    <groupId>org.dromara.dynamictp</groupId>
    <artifactId>dynamic-tp-spring-boot-starter-apollo</artifactId>
    <version>1.1.5</version>
</dependency>
```

## 核心特点

### 1. **动态参数调整**

- **实时生效**：通过集成主流配置中心（如 Nacos、Apollo、Zookeeper 等），支持运行时动态修改线程池的核心线程数、最大线程数、队列容量等参数，无需重启服务，适应流量波动。
- **多模式支持**：提供普通线程池（`DtpExecutor`）、IO 密集型线程池（`EagerDtpExecutor`）、调度线程池（`ScheduledDtpExecutor`）等，覆盖不同业务场景。

### 2. **零侵入设计**

- **配置与代码分离**：所有线程池配置均存储在配置中心，业务代码无需硬编码参数，仅需通过注解（如 `@DynamicTp`）或从 Spring 容器获取实例，降低耦合度。
- **兼容性**：支持管理 JUC 原生线程池、Spring 的 `ThreadPoolTaskExecutor`，以及第三方中间件（如 Tomcat、Dubbo、RocketMQ）的线程池。

### 3. **实时监控与告警**

- **多维指标采集**：监控活跃线程数、队列积压、任务拒绝率、执行耗时（TP90/TP99）等 20+ 指标，支持通过 Micrometer、JSON 日志或 Endpoint 输出。
- **多维度告警**：触发阈值时自动推送告警，涵盖配置变更、线程池活性、队列容量、任务超时等场景，支持钉钉、企微、飞书等通知渠道。

### 4. **任务增强与扩展性**

- **上下文传递**：通过任务包装器（如 `MdcTaskWrapper`、`TtlTaskWrapper`）支持线程池内传递链路追踪 ID、日志上下文等信息，解决异步任务上下文丢失问题。
- **SPI 扩展机制**：允许自定义配置中心适配、监控数据采集、告警通知等模块，满足个性化需求。

### 5. **轻量级与高可用**

- **快速接入**：基于 Spring Boot Starter 设计，引入依赖后仅需 3-4 步配置即可完成集成。
- **优雅关闭**：在服务终止时优先处理队列中的任务，避免资源浪费和数据丢失。
- **大规模验证**：参考美团内部成熟实践，适用于高并发分布式系统。

### 6. **中间件线程池管理**

- **集成第三方组件**：支持对 Tomcat、Jetty、Undertow、Dubbo、RocketMQ 等中间件的线程池进行动态调参和监控，统一管理全栈资源。

## 应用场景

适合微服务架构下需要弹性扩缩容和快速故障响应的场景

例如：消息推送系统中，根据不同下游渠道消费能力区分线程池执行推送

## 常见使用

### 注入Bean直接使用

```java
// 配置
@Bean
public DtpExecutor customExecutor() {
    return ThreadPoolBuilder.newBuilder()
            .threadPoolName("customExecutor")// 需与配置中心的spring.dynamic.tp.executors[0].threadPoolName一致
            .buildDynamic();  // 自动关联配置中心的参数
}

// 使用
@Resource
private ExecutorService customExecutor; // 注入线程池
```

### 通过DtpRegistry管理

```java
// 配置
@PostConstruct
public void init() {
    DtpExecutor executor = ThreadPoolBuilder.newBuilder()
                    .threadPoolName(PRE_FIX + groupId)
                    .corePoolSize(ThreadPoolConstant.COMMON_CORE_POOL_SIZE)
                    .maximumPoolSize(ThreadPoolConstant.COMMON_MAX_POOL_SIZE)
                    .keepAliveTime(ThreadPoolConstant.COMMON_KEEP_LIVE_TIME)
                    .timeUnit(TimeUnit.SECONDS)
                    .rejectedExecutionHandler(RejectedTypeEnum.CALLER_RUNS_POLICY.getName())
                    .allowCoreThreadTimeOut(false)
                    .workQueue(QueueTypeEnum.VARIABLE_LINKED_BLOCKING_QUEUE.getName(), ThreadPoolConstant.COMMON_QUEUE_SIZE, false)
                    .buildDynamic();
    DtpRegistry.register(executor, SOURCE_NAME);// 存到DtpRegistry类的static final Map中，key为线程池名称
}

// 使用
DtpExecutor executor = DtpRegistry.getExecutor(threadPoolName);// 通过线程池名称找线程池
```

## 特点及其实现原理

### 动态线程池配置更新

#### 监听变更

1. 从starter中的`DtpAutoConfiguration`类开始，引入`ApolloRefresher`类
2. `ApolloRefresher`中的`afterPropertiesSet`方法，添加自身为指定的namespace变更监听器
   1. namespace实际上是通过`spring.dynamic.tp.apollo.namespace`获取的，如果不配置则拿apollo配置的第一个namespace
3. `ApolloRefresher`的`onChange`方法会调用`com.dtp.core.DtpRegistry#refresh`
4. `com.dtp.core.DtpRegistry#refresh`会处理`List<ThreadPoolProperties>`，根据threadPoolName去`DtpRegistry`找对应的线程池
   1. `ThreadPoolProperties`中的配置来源于apollo配置：前缀为`spring.dynamic.tp.executors`
5. 重新根据apollo配置设置`maximumPoolSize`、`corePoolSize`、`keepAliveTime`等线程池参数

